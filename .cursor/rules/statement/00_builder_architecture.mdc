---
description:
globs:
alwaysApply: false
---
# SQL Builder Architecture
<!-- alwaysApply: true -->

## Objective
To ensure the SQL builder system maintains a clean, modular architecture using mixin patterns while providing a fluent interface for type-safe SQL construction and automatic parameter binding.

## Context
- The builder system provides fluent interfaces for SQL construction with automatic parameter binding
- Recent refactoring decomposed large builder classes into focused, reusable mixins
- Builders integrate seamlessly with the driver protocol and SQL object pipeline
- The factory pattern provides unified access through the `sql` object

## Rules

### 1. Mixin Architecture (MANDATORY)
<!-- alwaysApply: true -->
- **Mixin Organization**: Builder functionality must be organized into focused mixins in `sqlspec/statement/builder/mixins/`
- **Single Responsibility**: Each mixin handles a specific set of SQL clauses or functionality
- **Reusability**: Mixins should be reusable across multiple builder types where applicable
- **Required Mixins**:
    ```
    WhereClauseMixin      - WHERE conditions (select, update, delete)
    JoinClauseMixin       - JOIN operations (select)
    OrderByClauseMixin    - ORDER BY clauses (select)
    LimitOffsetClauseMixin - LIMIT/OFFSET clauses (select)
    ReturningClauseMixin  - RETURNING clauses (insert, update, delete)
    CommonTableExpressionMixin - WITH clauses (all builders)
    ```

### 2. Builder Class Structure (MANDATORY)
<!-- alwaysApply: true -->
- **Inheritance Pattern**: Main builder classes inherit from relevant mixins and BaseBuilder
- **Method Resolution Order**: Carefully manage MRO for mixin inheritance
- **Lean Implementation**: Builder classes should be primarily composition of mixins with minimal additional logic
- **Example Structure**:
    ```python
    class SelectBuilder(
        SelectColumnsMixin,
        FromClauseMixin,
        JoinClauseMixin,
        WhereClauseMixin,
        GroupByClauseMixin,
        HavingClauseMixin,
        OrderByClauseMixin,
        LimitOffsetClauseMixin,
        SetOperationMixin,
        CommonTableExpressionMixin,
        BaseBuilder,
    ):
        pass  # Minimal implementation
    ```

### 3. Parameter Binding (UNBREAKABLE RULE)
<!-- alwaysApply: true -->
- **Automatic Parameterization**: All values must be automatically parameterized to prevent SQL injection
- **Named Parameters**: Use dictionary-based parameter storage internally with auto-generated names
- **Collision Avoidance**: Generate unique parameter names (param_1, param_2, etc.)
- **Type Preservation**: Maintain Python types through to execution
- **Security First**: SQL injection must be impossible through the builder API

### 4. Fluent Interface Design (MANDATORY)
<!-- alwaysApply: true -->
- **Method Chaining**: All builder methods must return the builder instance for chaining
- **Immutability**: Methods should return new instances, not modify existing ones
- **Readable API**: Method names should mirror SQL structure for intuitive usage
- **Type Safety**: Maintain strong typing throughout the builder chain

### 5. Integration Requirements (MANDATORY)
<!-- alwaysApply: true -->
- **Driver Protocol Integration**: Builders must work directly with all three driver methods (execute, execute_many, execute_script)
- **SQL Object Conversion**: Builders must convert to SQL objects via `to_statement()` method
- **Parameter Extraction**: Parameters must be automatically extracted without manual intervention
- **Pipeline Compatibility**: Generated SQL objects must work with the StatementPipeline architecture

### 6. Factory Pattern (MANDATORY)
<!-- alwaysApply: true -->
- **Unified Access**: The `sql` factory object provides access to all builders and expressions
- **Dynamic Columns**: Support `sql.column_name` syntax for dynamic column references
- **Function Library**: Provide comprehensive SQL functions (aggregates, string, math, JSON, window)
- **Raw SQL Integration**: Support parsing raw SQL strings into builders for enhancement

### 7. Expression System (MANDATORY)
<!-- alwaysApply: true -->
- **SQLGlot Integration**: Use sqlglot expressions as the underlying representation
- **Expression Composition**: Support complex expression building and reuse
- **Dialect Awareness**: Generate correct SQL for target database dialects
- **Function Wrapping**: Provide convenient wrappers for SQL functions and operators

### 8. Convenience Methods (MANDATORY)
<!-- alwaysApply: true -->
- **Common Patterns**: Provide convenience methods for frequent operations
- **Type-Safe Comparisons**: Support type-safe comparison operations
- **Null Handling**: Provide explicit null checking methods
- **Range Operations**: Support BETWEEN, IN, LIKE operations with proper parameterization
- **Example Methods**:
    ```python
    .where_eq(column, value)        # column = value
    .where_between(column, low, high) # column BETWEEN low AND high
    .where_like(column, pattern)    # column LIKE pattern
    .where_in(column, values)       # column IN (values)
    .where_is_null(column)          # column IS NULL
    ```

### 9. Testing Requirements (MANDATORY)
<!-- alwaysApply: true -->
- **Builder Testing**: Test each mixin independently with focused unit tests
- **Integration Testing**: Test complete builder workflows with driver integration
- **Parameter Testing**: Verify parameter binding and extraction for all operations
- **SQL Generation Testing**: Test SQL generation for all supported dialects
- **Type Safety Testing**: Verify type safety through the entire builder chain

### 10. File Organization (MANDATORY)
<!-- alwaysApply: true -->
- **Mixin Directory**: All mixins in `sqlspec/statement/builder/mixins/`
- **Mixin Naming**: Use descriptive names ending in `Mixin` (e.g., `WhereClauseMixin`)
- **Builder Files**: Lean builder files that primarily compose mixins
- **Export Management**: Proper `__init__.py` files for clean imports
- **Documentation**: Clear documentation for each mixin's purpose and usage

### 11. Mixin Implementation Patterns (MANDATORY)
<!-- alwaysApply: true -->
- **State Access**: Mixins access shared state through `self._expression` and `self._parameters`
- **Helper Methods**: Utility methods should be in BaseBuilder or appropriate mixins
- **Parameter Management**: Use `add_parameter()` and `get_unique_parameter_name()` for parameter handling
- **Expression Building**: Use sqlglot expression builders for type-safe SQL construction

### 12. Builder Enhancement (MANDATORY)
<!-- alwaysApply: true -->
- **Raw SQL Enhancement**: Support enhancing parsed raw SQL with additional builder methods
- **Filter Integration**: Support SQLSpec filters through builder methods
- **Subquery Support**: Proper handling of subqueries and CTEs
- **Complex Expressions**: Support for complex expressions and custom SQL fragments

## Common Anti-Patterns to Avoid
- **Large Monolithic Builders**: Don't create massive builder classes; use mixins
- **Manual Parameter Handling**: Never manually manage SQL parameters
- **SQL String Concatenation**: Always use parameterized queries
- **Mixin Overlap**: Avoid overlapping functionality between mixins
- **Tight Coupling**: Don't tightly couple mixins to specific builder implementations

## Integration Examples
```python
# Factory usage
from sqlspec import sql

# Builder creation and chaining
query = (
    sql.select(sql.id, sql.name, sql.email)
    .from_("users")
    .where_eq("active", True)
    .where_between("created_at", start_date, end_date)
    .order_by("name")
    .limit(50)
)

# Direct execution with driver
result = driver.execute(query, schema_type=User)

# Raw SQL enhancement
enhanced = (
    sql.select("SELECT * FROM users WHERE department = 'engineering'")
    .where_between("salary", 50000, 150000)
    .order_by("hire_date DESC")
    .limit(10)
)
```

## Cross-References
- See internal docs REF-008 for SQL Builder System architecture details
- See internal docs REF-009 for SQL Factory API patterns
- See `.cursor/rules/sql/01_sql_class_implementation.mdc` for SQL object integration
- See `.cursor/rules/adapters/01_execution_method_structure.mdc` for driver integration

## Exceptions
- Legacy builder implementations may temporarily deviate during migration
- Database-specific builders may require unique methods not suitable for mixins
- Performance-critical paths may require optimized implementations
