---
description:
globs:
alwaysApply: false
---
# SQLSpec Architecture Summary
<!-- alwaysApply: true -->

## Objective
To provide a comprehensive overview of the SQLSpec architecture, integrating recent debugging insights, refactor patterns, and established best practices into a cohesive development framework.

## Context
- SQLSpec is a SQL query framework providing type-safe, secure SQL operations across multiple databases
- Recent debugging sessions revealed critical patterns and anti-patterns that must be codified
- Major refactors (Builder Cleanup, Adapter Execution, Parse vs Parse One, SQL Refactor) have established new architectural standards
- The system emphasizes security, performance, and developer experience through unified APIs

## Core Architectural Principles

### 1. Single-Pass Processing Pipeline (UNBREAKABLE RULE)
<!-- alwaysApply: true -->
- **Parse Once**: SQL strings parsed into sqlglot expressions once and cached
- **Transform Once**: All transformations applied in a single pipeline pass
- **Validate Once**: Validation performed once with results cached
- **Implementation**: StatementPipeline with SQLProcessingContext manages all processing
- **Reference**: See [REF-011] SQLStatement & StatementPipeline architecture

### 2. SQL Object as Single Source of Truth (MANDATORY)
<!-- alwaysApply: true -->
- **Authority**: SQL object is authoritative for SQL string, parameters, and execution mode
- **Properties**: `is_many`, `is_script`, `to_sql()`, `parameters` must provide accurate state
- **No Separate Parameters**: Never pass separate execution mode or parameter arguments
- **Critical Bug Prevention**: Properties must return actual instance variables, not processed state flags

### 3. Unified Adapter Execution Structure (MANDATORY)
<!-- alwaysApply: true -->
- **Required Methods** (in exact order):
    1. `_execute_statement` - Main dispatch method
    2. `_execute` - Single-statement execution
    3. `_execute_many` - Batch execution
    4. `_execute_script` - Script execution
- **Reference Implementation**: SQLite adapter serves as canonical reference
- **Consistency**: All adapters must follow this structure exactly

### 4. Builder Mixin Architecture (MANDATORY)
<!-- alwaysApply: true -->
- **Modular Design**: Large builder classes decomposed into focused mixins
- **Reusability**: Mixins shared across multiple builder types where applicable
- **Factory Access**: Unified access through `sql` factory object
- **Security**: Automatic parameter binding prevents SQL injection

### 5. Comprehensive Testing Patterns (MANDATORY)
<!-- alwaysApply: true -->
- **Mock Setup**: Use `MagicMock` for context manager objects, not basic `Mock`
- **Assertion Accuracy**: Assert on actual mock objects used by production code
- **Execution Coverage**: Test all three execution paths independently
- **Parameter Flow**: Verify end-to-end parameter handling and transformation

## System Components

### Core SQL Processing
- **SQL Class**: Central immutable object with single-pass processing via `_ensure_processed()`
- **StatementPipeline**: Orchestrates transformation, validation, and analysis stages
- **SQLProcessingContext**: Shared workspace for pipeline stages
- **ProcessorProtocol**: Contract for transformers, validators, and analyzers

### Builder System
- **Base Builders**: SelectBuilder, InsertBuilder, UpdateBuilder, DeleteBuilder, MergeBuilder
- **Mixins**: WhereClauseMixin, JoinClauseMixin, OrderByClauseMixin, etc.
- **Factory**: `sql` object providing unified access to builders and expressions
- **Expression System**: SQLGlot-based with automatic parameter binding

### Database Adapters
- **Protocol Architecture**: SyncDriverAdapterProtocol, AsyncDriverAdapterProtocol
- **Execution Structure**: Standardized four-method execution pattern
- **Configuration**: TypedDict-based configuration with connection pooling
- **Error Handling**: Database-specific errors mapped to SQLSpec exception hierarchy

### Extensions and Integrations
- **Framework Extensions**: Litestar, FastAPI, Flask integration patterns
- **AioSQL Integration**: File-based SQL with full SQLSpec power and singleton caching
- **Instrumentation**: OpenTelemetry and Prometheus integration for observability

## Critical Debugging Insights

### 1. Property Implementation Bug (RESOLVED)
- **Issue**: `is_many` and `is_script` returning wrong values
- **Fix**: Properties must return actual instance variables
- **Prevention**: All properties must be unit tested

### 2. Parameter Handling Patterns
- **Raw Parameters**: Use `_raw_parameters` for validation-bypass operations
- **Processed Parameters**: Use `parameters` property for fully processed parameters
- **Script Execution**: Always use `ParameterStyle.STATIC` for parameter substitution

### 3. Mock Setup Requirements
- **Context Managers**: Use `MagicMock` for objects needing `__enter__`/`__exit__`
- **Assertion Targets**: Assert on actual mock path used by production code
- **Complete Configuration**: Set up entire mock chain used by adapters

### 4. Script Execution Requirements
- **Multi-Statement Parsing**: Use `sqlglot.parse()` not `sqlglot.parse_one()`
- **Parameter Preservation**: `as_script()` must preserve transformed expressions
- **Literal Conversion**: Convert all parameters to literals for execution

## Development Workflows

### Adding New Database Adapter
1. Study SQLite adapter as reference implementation
2. Implement standardized execution method structure
3. Set up proper TypedDict configuration
4. Create comprehensive unit and integration tests
5. Follow mock setup patterns for testing
6. Document database-specific features and limitations

### Modifying SQL Class
1. Understand current pipeline state management
2. Preserve single-pass processing principle
3. Use correct parameter access patterns (raw vs processed)
4. Invalidate processed state when SQL content changes
5. Test all property implementations thoroughly

### Creating Builder Mixins
1. Focus on single responsibility (specific SQL clauses)
2. Ensure reusability across builder types
3. Use proper parameter binding patterns
4. Integrate with existing mixin hierarchy
5. Test independently and in combination

### Writing Adapter Tests
1. Use `MagicMock` for context manager objects
2. Trace exact mock path used by production code
3. Test all three execution modes independently
4. Verify parameter flow end-to-end
5. Cover error scenarios and edge cases

## Performance Optimizations

### Caching Strategies
- **SQL Processing**: `_ProcessedState` caches all pipeline artifacts
- **AioSQL**: Singleton metaclass caches parsed queries forever
- **Expression Reuse**: Shared sqlglot expressions across similar queries

### Resource Management
- **Connection Pooling**: Proper lifecycle management for database connections
- **Context Managers**: Automatic cleanup of cursors and resources
- **Lazy Loading**: Processing only occurs when needed via `_ensure_processed()`

### Pipeline Efficiency
- **Single Pass**: No redundant parsing or transformation
- **State Preservation**: Relevant context preserved during operations
- **Minimal Reprocessing**: Only invalidate state when necessary

## Security Considerations

### SQL Injection Prevention
- **Automatic Parameterization**: All builder values automatically parameterized
- **Parameter Validation**: Comprehensive validation of parameter binding
- **Static Analysis**: Validation and analysis stages catch potential issues

### Input Validation
- **Type Safety**: Strong typing throughout the system
- **Parameter Bounds**: Validation of parameter counts and types
- **SQL Structure**: sqlglot parsing validates SQL structure

## Observability and Debugging

### Instrumentation
- **OpenTelemetry**: Distributed tracing for SQL operations
- **Prometheus**: Metrics for performance and error tracking
- **Structured Logging**: Contextual logging throughout the pipeline

### Debug Capabilities
- **Pipeline Inspection**: Access to all processing stages and results
- **Parameter Tracing**: Visibility into parameter transformation
- **Expression Analysis**: sqlglot expression tree inspection

## Cross-References

### Rule Documentation
- `.cursor/rules/sql/01_sql_class_implementation.mdc` - SQL class requirements
- `.cursor/rules/adapters/01_execution_method_structure.mdc` - Adapter execution patterns
- `.cursor/rules/testing/01_adapter_testing_patterns.mdc` - Testing standards
- `.cursor/rules/statement/00_builder_architecture.mdc` - Builder system architecture

### Internal Documentation
- `docs/internal/013_critical_debugging_insights.md` - Detailed debugging findings
- `docs/internal/011_sqlstatement_pipeline.md` - Pipeline architecture
- `docs/internal/008_sql_builder_system.md` - Builder system details
- `docs/internal/010_aiosql_integration.md` - AioSQL integration patterns

### Refactor Plans
- `ADAPTER_EXECUTION_REFACTOR_PLAN.md` - Adapter standardization roadmap
- `BUILDER_CLEANUP.md` - Mixin refactoring guidelines  
- `PARSE_VS_PARSE_ONE.md` - Script execution improvements
- `SQL_REFACTOR.md` - SQL class optimization patterns

## Future Development Priorities

### Immediate Actions
1. Apply adapter execution refactor to all 9 identified adapters
2. Complete builder mixin decomposition
3. Implement comprehensive testing patterns across all adapters
4. Validate single-pass processing in all components

### Medium-Term Goals
1. Optimize pipeline performance with advanced caching
2. Extend instrumentation and observability features
3. Add support for additional database features
4. Enhance type safety with advanced generic patterns

### Long-Term Vision
1. Complete database ecosystem coverage
2. Advanced query optimization capabilities
3. Real-time query analysis and suggestions
4. Integration with modern data engineering workflows

## Success Metrics

### Code Quality
- All adapter unit tests passing (100% success rate)
- High test coverage (95%+ unit, 80%+ integration)
- Zero SQL injection vulnerabilities
- Consistent patterns across all adapters

### Performance
- Single-pass processing for all SQL operations
- Efficient resource utilization and cleanup
- Minimal processing overhead
- Fast test execution (<1ms per unit test)

### Developer Experience
- Intuitive API with fluent interfaces
- Comprehensive error messages and debugging info
- Clear documentation and examples
- Seamless integration across frameworks

**This architecture summary serves as the definitive guide for SQLSpec development, ensuring consistency, security, and performance across the entire system.**
