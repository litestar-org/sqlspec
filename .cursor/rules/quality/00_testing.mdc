---
description: 
globs: 
alwaysApply: true
---
# Testing Standards

## Objective
To ensure the reliability, correctness, and stability of the codebase through a comprehensive, well-structured, and maintainable testing approach, covering unit, integration, and other relevant test types.

## Context
- **Framework**: `pytest` is the test runner.
- **Coverage**: `pytest-cov` is used for test coverage analysis. Configuration is in `pyproject.toml` (`[tool.coverage]`).
- **Database Testing**: `pytest-databases` is used for integration tests involving real database services.
- **Test Locations**: Unit tests are in `tests/unit/`, integration tests in `tests/integration/`.
- **Fixtures**: Shared test setup and resources are managed via pytest fixtures, often located in `tests/fixtures/` or `conftest.py`.

## Rules

### 1. General Testing Principles
- **Write Tests for All New Code**: All new features, bug fixes, or significant refactoring must be accompanied by tests.
- **Test Coverage**: Aim for high test coverage. While specific targets from drafts (e.g., 95% unit, 80% integration) are good goals, the primary directive from `project.instructions.md` is "high test coverage." Ensure new tests pass before submitting code.
- **Parameterized Tests**: Design tests to be as parameterized and complete as possible, covering various scenarios and edge cases. Use `pytest.mark.parametrize` extensively.
    ✅ **Good:** `@pytest.mark.parametrize("input_val, expected_output", [(1, 2), (3, 4)])`
- **Isolated Tests**: Ensure each test function is independent and can run in isolation without affecting or being affected by other tests. Integration tests must ensure proper data cleanup.
- **Descriptive Naming**: Use clear, descriptive names for test files and functions that indicate what is being tested and under what conditions.

### 2. Test Structure and Location
- **Unit Tests (`tests/unit/`)**:
    - **Location**: Place unit tests in `tests/unit/`.
    - **Mirroring Structure**: Mirror the `sqlspec/` directory structure where appropriate (e.g., unit tests for `sqlspec/adapters/foo.py` should be in `tests/unit/test_adapters/test_foo.py`).
    - **Focus**: Test individual functions, methods, or classes in isolation, mocking external dependencies (databases, network calls, etc.) using `unittest.mock.Mock` or `unittest.mock.AsyncMock`.
- **Integration Tests (`tests/integration/`)**:
    - **Location**: Place integration tests in `tests/integration/`.
    - **Focus**: Test the interaction between components or with actual database services and external systems.
    - **Organization**: Can be organized by adapter (e.g., `tests/integration/test_adapters/test_psycopg/`) or feature.

### 3. Pytest Fixtures
- **Usage**: Utilize `pytest` fixtures for test setup and teardown, especially for database connections, shared resources, or complex object instantiation.
- **Location**: Look for existing fixtures in `tests/fixtures/` or within test modules (`conftest.py` files or directly in test files if scope is limited).
- **Clarity & Scope**: Fixtures should have clear, descriptive names and docstrings. Scope fixtures appropriately (`function`, `module`, `session`).
- **`sqlspec.utils.fixtures`**: For loading test data from files (e.g., JSON, SQL), consider using helper utilities if available in `sqlspec.utils.fixtures` (as suggested in a draft rule), like `open_fixture`.
    ✅ **Good (conceptual example from draft):**
    ```python
    # tests/fixtures/example_data.py
    import pytest
    # from sqlspec.utils.fixtures import open_fixture # If this utility exists

    @pytest.fixture
    def user_data(fixture_file_opener): # Assuming a fixture_file_opener or similar
        return fixture_file_opener("users.json")
    ```
- **Resource Cleanup**: Ensure fixtures that allocate resources (e.g., temporary files, database entries) clean them up properly, typically using `yield` with a `try...finally` block or context managers.

### 4. Pytest Markers
- **Usage**: Use `pytest.mark` to categorize tests (e.g., `@pytest.mark.integration`, `@pytest.mark.postgres`, markers for specific adapters as defined in `pyproject.toml`).
- **Configuration**: Refer to `[tool.pytest.ini_options]` in `pyproject.toml` for the list of registered markers.

### 5. Database Integration Test Specifics
- **`pytest-databases`**: Leverage `pytest-databases` fixtures for managing connections to real database instances during integration tests.
- **Adapter Test Structure (Recommended Pattern from Drafts)**:
    - **Unit Tests**: `tests/unit/test_adapters/test_{adapter_name}/` (e.g., `test_config.py`, `test_driver.py`) using mocks.
    - **Integration Tests**: `tests/integration/test_adapters/test_{adapter_name}/` (e.g., `test_connection.py`, `test_driver.py`) using real connections.

### 6. Test Execution
- **Local Execution**: Run tests frequently during development (`uv run pytest` or `make test`).
- **Pre-commit/CI**: Ensure all tests pass as part of pre-commit checks and CI pipelines.

## Exceptions
- Trivial, self-evident code (e.g., simple data classes with no logic, constants) might not require dedicated unit tests but should be covered by integration tests where they are used.
- Tests for fixture utilities themselves might not strictly follow all fixture usage rules.
