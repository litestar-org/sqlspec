---
description:
globs:
alwaysApply: true
---
# Adapter Testing Patterns
<!-- alwaysApply: true -->

## Objective
To ensure adapter tests are correctly structured, comprehensive, and avoid common pitfalls discovered during recent debugging. This includes rigorous mock setup for sync/async operations, context manager handling, and parameter flow verification across all execution modes.

## Context
- Adapter testing revealed critical issues with mock setup, especially for context managers and asynchronous operations, leading to tests that didn't accurately reflect production code paths.
- Proper mock configuration (e.g., using `MagicMock` for objects requiring `__enter__`/`__exit__`) is essential for testing the actual execution paths.
- Parameter flow testing must verify the complete pipeline from the `SQL` object to database driver execution.
- Different execution modes (single, many, script) require specific testing approaches and assertions.
- Unit tests must effectively mock all external interactions, including database connections and cursors.

## Rules

### 1. Mock Setup Requirements (CRITICAL)
<!-- alwaysApply: true -->
- **Use `MagicMock` for Context Managers**: Database cursors or connections that are used as context managers (e.g., `with driver.get_connection() as conn:`, `with conn.cursor() as cursor:`) MUST be mocked using `unittest.mock.MagicMock`, not basic `unittest.mock.Mock`. `MagicMock` provides default implementations for magic methods like `__enter__` and `__exit__`.
    ```python
    from unittest.mock import Mock, MagicMock
    # Assuming ConnectionType and CursorType are the actual types being mocked

    @pytest.fixture
    def mock_cursor() -> "MagicMock": # Type hint as MagicMock for clarity
        cursor = MagicMock(spec=CursorType) # spec helps catch incorrect attribute access
        cursor.__enter__.return_value = cursor # __enter__ must return the mock itself
        cursor.__exit__.return_value = None    # __exit__ typically returns None or False
        return cursor

    @pytest.fixture
    def mock_connection(mock_cursor: "MagicMock") -> "MagicMock":
        connection = MagicMock(spec=ConnectionType)
        connection.cursor.return_value = mock_cursor # Or MagicMock(spec=CursorType) if created here
        # If connection itself is a context manager:
        # connection.__enter__.return_value = connection
        # connection.__exit__.return_value = None
        return connection
    ```
- **Async Mocking**: For asynchronous adapters, use `unittest.mock.AsyncMock` for awaitable methods and `MagicMock` (or `AsyncMock` if it also acts as an async context manager) for async context managers (`async with ...`).
    ```python
    from unittest.mock import AsyncMock, MagicMock

    @pytest.fixture
    async def mock_async_cursor() -> "MagicMock": # Or AsyncMock if it has async methods
        # For an async context manager
        cursor = MagicMock(spec=AsyncCursorType) # Or AsyncMock
        mock_async_enter = AsyncMock(return_value=cursor)
        mock_async_exit = AsyncMock(return_value=None)
        cursor.__aenter__ = mock_async_enter
        cursor.__aexit__ = mock_async_exit
        # For awaitable methods on the cursor itself
        cursor.execute = AsyncMock(return_value=...)
        cursor.fetchall = AsyncMock(return_value=[])
        return cursor
    ```
- **Complete Mock Configuration**: Ensure all methods and attributes on mocks that will be accessed by the code under test are appropriately configured (e.g., `return_value`, `side_effect`).
- **`spec` Parameter**: Use the `spec` parameter in `Mock`, `MagicMock`, and `AsyncMock` constructors, providing the actual class being mocked. This helps catch typos and accesses to non-existent attributes/methods on the mock.

### 2. Assertion Targets (MANDATORY)
<!-- alwaysApply: true -->
- **Assert on Actual Used Mock**: Tests MUST assert on the mock object instance that is actually used by the driver/code under test, not a different mock instance or a mock of a factory method if the instance is what's used.
- **Context Manager Cursor**: For drivers using `with ... as cursor:`, assertions for cursor methods (e.g., `execute`) should be on the object returned by `__enter__` (or `__aenter__` for async).
    - Example: `mock_connection.cursor.return_value.__enter__.return_value.execute.assert_called_once_with(...)`
- **Direct Cursor/Connection**: If a cursor or connection object is obtained and then its methods are called directly, assert on that object.
    - Example: `mock_cursor.execute.assert_called_once_with(...)`
- **Avoid Mocking `__getitem__`, `__iter__` directly on `Mock`**: Basic `Mock` objects do not support direct assignment to magic methods like `__getitem__` or `__iter__` to make them behave as expected. Use `MagicMock` which provides default implementations, or configure `return_value` for these methods carefully if using `Mock` (e.g., `mock_instance.__iter__.return_value = iter([])`).

### 3. Parameter Flow Testing (MANDATORY)
<!-- alwaysApply: true -->
- **Test All Execution Modes**: Parameter flow from the `SQL` object to the database driver call (`execute`, `executemany`, `executescript`, or equivalent) must be tested for single, many, and script execution modes.
- **SQL String and Parameters**: Verify that the correct SQL string (with appropriate placeholder style) and the correctly structured parameters are passed to the mocked database driver method.
- **Placeholder Style**: Test that the adapter applies its native `placeholder_style` for single/many executions and that `ParameterStyle.STATIC` is effectively used for script execution (parameters rendered as literals).
    ```python
    # Example for testing single execution parameter flow
    @pytest.mark.parametrize(
        "sql_in, params_in, expected_sql_out, expected_params_out",
        [("SELECT * FROM t WHERE id = ?", (1,), "SELECT * FROM t WHERE id = ?", (1,))]
    )
    def test_single_execution_parameter_flow(
        driver: "BaseDriver", mock_db_cursor: "MagicMock", sql_in: "str", params_in: "tuple", expected_sql_out: "str", expected_params_out: "tuple"
    ):
        statement = SQL(sql_in, parameters=params_in)
        # Assuming driver._execute is the method that eventually calls db_cursor.execute
        # We need to ensure mock_db_cursor is what driver._execute will use.
        # This typically involves mocking the connection and its cursor() method to return mock_db_cursor.
        # For simplicity in this example, let's assume driver._execute directly uses a cursor it gets elsewhere that is mock_db_cursor.
        # A more realistic setup would involve mocking `driver._get_cursor` or `connection.cursor`:
        # mock_connection = MagicMock()
        # mock_connection.cursor.return_value.__enter__.return_value = mock_db_cursor
        # driver._execute(statement.to_sql(driver.placeholder_style), statement.parameters, connection=mock_connection)
        mock_db_cursor.execute.assert_called_once_with(expected_sql_out, expected_params_out)
    ```

### 4. Script Execution Testing (MANDATORY)
<!-- alwaysApply: true -->
- **Multi-Statement Verification**: Test that scripts containing multiple SQL statements result in all statements being passed to the database driver's script execution method (e.g., `executescript`).
- **Parameter Substitution for Scripts**: Verify that parameters in `SQL` objects intended for script execution are correctly rendered as static literals within the SQL string passed to the driver, as per `ParameterStyle.STATIC`.
- **Correct Driver Method**: Ensure the adapter's `_execute_script` method calls the appropriate underlying database library method for executing scripts (e.g., `cursor.executescript()` for SQLite).

### 5. Execution Mode Dispatch Testing (MANDATORY)
<!-- alwaysApply: true -->
- **`_execute_statement` Logic**: Test the dispatch logic within the adapter's `_execute_statement` method.
- **`SQL` Object Properties**: Verify that `_execute_statement` correctly uses `statement.is_many` and `statement.is_script` to call the appropriate internal method (`_execute`, `_execute_many`, or `_execute_script`).
- **Coverage**: Each execution path within `_execute_statement` must be independently tested by constructing `SQL` objects with the relevant properties.

### 6. Result Type and Structure Testing (MANDATORY)
<!-- alwaysApply: true -->
- **SELECT vs. DML/DDL**: Test that the adapter's result wrapping logic correctly distinguishes between queries that return rows (SELECT) and those that don't (INSERT, UPDATE, DELETE, DDL).
- **Result Object Verification**: Assert that the correct type of result object (e.g., `SelectResult`, `ExecuteResult`) is returned and that its structure (e.g., column names, row data, affected row counts) is as expected.
- **Mock `cursor.description` and `cursor.rowcount`**: Appropriately mock `cursor.description` (e.g., `None` for DML, tuple of tuples for SELECT) and `cursor.rowcount` to test result wrapping.

### 7. Error Handling Testing (MANDATORY)
<!-- alwaysApply: true -->
- **Database Error Wrapping**: Test that exceptions raised by the underlying database driver are caught and wrapped into appropriate `SQLSpec` exceptions (e.g., `RepositoryError`, `IntegrityError`, `NotFoundError`) via `sqlspec.exceptions.wrap_exceptions`.
- **Connection Errors**: Test scenarios involving connection failures.
- **Invalid Parameters/Configuration**: Test how the adapter handles invalid input that might not be caught by the `SQL` object itself (though this should be rare).

### 8. Mock Fixture Standards (MANDATORY)
<!-- alwaysApply: true -->
- **Consistent Naming**: Use clear and consistent naming for mock fixtures (e.g., `mock_db_connection`, `mock_db_cursor`).
- **Scope**: Scope fixtures appropriately (e.g., `function`, `module`).
- **Type Annotations**: Provide accurate type hints for mock fixtures (e.g., `-> "MagicMock"`).

## Cross-References
- See `.cursor/rules/adapters/01_execution_method_structure.mdc` for the execution method structure that these tests verify.

## Common Pitfalls to Avoid
- **Incorrect Mock Type**: Using `Mock` instead of `MagicMock` for context managers.
- **Missing `__enter__` or `__aenter__` Return**: Forgetting to set `mock_cursor.__enter__.return_value = mock_cursor`.
- **Asserting on the Wrong Mock**: Asserting on `mock_connection.cursor` instead of `mock_connection.cursor.return_value.__enter__.return_value` (or equivalent).
- **Incomplete Parameter Flow**: Not testing the full path from `SQL(sql, params)` through `driver._execute_statement` to the final `cursor.execute(final_sql, final_params)`.
- **Ignoring Execution Modes**: Only testing single execution and not `_execute_many` or `_execute_script` paths.

## Integration Testing Requirements
- **Data Cleanup**: Ensure proper cleanup of test data between tests
- **Connection Pool Testing**: Test pool lifecycle and connection management

## Exceptions
