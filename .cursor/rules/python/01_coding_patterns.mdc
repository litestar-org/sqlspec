---
description:
globs:
alwaysApply: false
---
# Python Coding Patterns & Best Practices (Strict)

## Objective
To promote robust, readable, maintainable, and **CLEAN, SOLID** Python code by adhering to established best practices for common programming patterns, error handling, and code organization, with a strong emphasis on conciseness and modularity.

## Context
These rules apply to general Python development within the project, complementing specific rules for style, typing, and documentation. They reflect a strong project preference for concise, in-lined, and well-structured logic.

## Rules

### Code Design and Structure (SOLID Principles)
- **Write CLEAN and SOLID Code**: Actively apply SOLID principles (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) in the design of classes and modules.
- **Consolidate Related Logic**: Identify tightly related steps or pieces of logic that serve a single, clear purpose. Consolidate these into a single function or method to improve coherence and reduce fragmentation. Re-evaluate if existing separate functions should be merged.
- **Decompose Long Functions/Methods**: Strictly avoid overly long functions or methods. If a function performs multiple distinct tasks or exceeds a reasonable length (e.g., ~30-50 lines as a soft guide, depending on complexity), break it down into smaller, well-named functions, each with a single responsibility. This is critical for readability, testability, and reusability.
    ✅ **Good:**
    ```python
    def _validate_input(data: 'dict') -> 'None': ...
    def _process_core_logic(validated_data: 'dict') -> 'Result': ...
    def _format_output(result: 'Result') -> 'str': ...

    def handle_request(raw_data: 'dict') -> 'str':
        _validate_input(raw_data)
        processed_data = _process_core_logic(raw_data)
        return _format_output(processed_data)
    ```
    ❌ **Avoid:** A single `handle_request` function containing all validation, processing, and formatting logic spanning many lines.

### Variable Assignments and Expressions (Strict Conciseness)
- **MANDATORY: Minimize Needless Variables - Favor In-lining**: It is a **strong requirement** to avoid creating temporary variables that are used only once. **ALWAYS** favor in-lining expressions for conciseness.
    - Use `typing.cast` where necessary to satisfy the type checker when in-lining complex expressions.
    - This rule is stricter than general advice; the preference is decidedly for in-lining unless it *severely* impacts readability of a complex, non-obvious step.
    ✅ **Good (Mandatory Style):**
    ```python
    from typing import cast
    # Assume process_result and raw_data exist
    return process_result(cast('str', raw_data['value']))
    ```
    ❌ **Avoid (Violates Project Style):**
    ```python
    # This is too verbose for the project's preferred style.
    raw_value = raw_data['value'] 
    processed_value = process_result(str(raw_value)) # str() might be an oversimplification
    return processed_value
    ```
- **Clarity Exception (Rare)**: Only if in-lining an exceptionally complex or obscure expression makes the code significantly harder to understand, may a temporary variable with a very descriptive name be used. This should be an infrequent exception, not the norm.

### Configuration Patterns
- **Consistency**: For components requiring configuration (e.g., database adapters), follow existing patterns observed in the codebase.
- **Example**: `sqlspec/adapters/bigquery/config/` and `sqlspec/adapters/psycopg/config/` suggest a pattern of dedicated config modules. Strive for similar clarity and separation of concerns when introducing new configurable components.

### Error Handling
- **Robustness**: Implement robust error handling.
- **Custom Exceptions**: Define custom exceptions in `sqlspec/exceptions.py` where appropriate to provide specific error information. All custom exceptions should inherit from `SQLSpecError` or one of its more specific descendants.
    ✅ **Good:** `raise SpecificCustomException("Descriptive error message with context")`
    ❌ **Avoid:** Generic `raise Exception("Something went wrong")`
- **Contextual Exceptions**: Ensure exceptions are raised with sufficient context to be useful for debugging. Original exceptions should be wrapped if re-raising to add context (e.g., `raise NewException("More context") from original_exception`).
- **Propagation to Adapter Layer**: Strive to let exceptions propagate up to the driver adapter layer (i.e., the code within `sqlspec/adapters/`). This layer is responsible for catching raw database driver exceptions or other operational errors.
- **`wrap_exceptions` Context Manager**: Within the driver adapter layer (specifically in methods that directly interact with the database driver/client), use the `sqlspec.exceptions.wrap_exceptions` context manager. This utility (to be consistently implemented across adapters) should be used to catch common underlying database errors (e.g., connection errors, integrity errors from the DB driver) and re-raise them as appropriate `sqlspec` specific exceptions (e.g., `RepositoryError`, `IntegrityError`, `NotFoundError`).
    ✅ **Good (Conceptual example within an adapter method):**
    ```python
    from sqlspec.exceptions import wrap_exceptions, RepositoryError #, logger

    def execute_query(self, query: 'str', params: 'dict') -> 'None':
        try:
            with wrap_exceptions(): # This will catch driver errors and raise RepositoryError
                # raw_driver_connection.execute(query, params)
                # ...
                pass # Replace with actual driver call
        except RepositoryError as e:
            # logger.error("Repository error during query execution: %s", e)
            raise
    ```
- **Avoid Needless Catch-Re-raise**: Below the adapter layer (e.g., in service logic or utilities), do not needlessly catch and re-raise exceptions unless adding significant, valuable context or handling a specific case that justifies the interception. Prefer allowing exceptions to propagate to the adapter layer or a designated higher-level handler.
- **Logging**: Use the `logging` module for error reporting and debugging, especially when exceptions are caught and handled. See "Logging Practices" for more details.

### Logging Practices
- **Use `logging` Module**: Employ the standard `logging` module for all application logging.
- **No `print` for Logging**: Do not use `print()` statements for debugging or logging in library code. `print()` should only be used in CLIs or scripts where direct console output is intended.
- **No F-strings in Log Messages**: Avoid using f-strings directly in logging calls (e.g., `logger.error(f"An error occurred: {variable}")`). Instead, use lazy formatting with arguments (e.g., `logger.error("An error occurred: %s", variable)` or `logger.error("An error: %s", var, exc_info=True)`).
    ✅ **Good:** `logger.info("Processing item %s", item_id)`
    ❌ **Avoid:** `logger.info(f"Processing item {item_id}")`
- **Meaningful Logs**: Ensure log messages are meaningful and provide sufficient context to understand the event or error.

### Anti-Patterns to Avoid (Reinforced)
- **Global Variables**: Strictly avoid global variables where possible.
- **Overly Complex One-Liners**: While in-lining is preferred (see "Variable Assignments"), this does not mean creating unreadable, overly dense one-liners. If an in-lined expression becomes too complex, breaking it into logically named intermediate expressions (still in-lined if used once) or a helper function is better.
- **Directly Committing Secrets**: Never commit secrets. Use environment variables or secure configuration methods.

## Exceptions
- Global constants (all uppercase) are acceptable.
- The strict in-lining rule may be relaxed for exceptionally complex, non-obvious expressions where a well-named temporary variable demonstrably aids understanding, but this should be rare and justified.
