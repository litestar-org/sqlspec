---
description:
globs:
alwaysApply: true
---
# Database Adapter Development
<!-- alwaysApply: true -->

## Objective
To ensure that new database adapters are consistent with the existing adapter architecture, maintain high quality, and integrate seamlessly into the `sqlspec` ecosystem.

## Context
- New database adapters are a core extensibility point for `sqlspec`.
- Consistency in design and implementation is crucial for maintainability and user experience.
- `project.instructions.md` provides specific guidance on adapter placement and configuration patterns.

## Rules

### 1. Adherence to Existing Patterns
<!-- alwaysApply: true -->
- **Study Existing Adapters**: Before developing a new adapter, thoroughly review the structure and implementation of existing adapters in `sqlspec/adapters/`.
- **Follow Established Patterns**: Emulate the design patterns, class structures, configuration handling (e.g., dedicated config modules like in `sqlspec/adapters/bigquery/config/` or `sqlspec/adapters/psycopg/config/`), and driver interaction logic found in mature adapters.
- **Consistency is Key**: Strive for consistency in API exposure, error handling, and feature implementation comparable to other adapters.

### 2. Directory Structure and Placement
<!-- alwaysApply: true -->
- **Location**: New database adapters must be placed in a new subdirectory within `sqlspec/adapters/` (e.g., `sqlspec/adapters/newdb/`).
- **Modularity**: Organize the adapter code into logical modules (e.g., `config.py`, `driver.py`, `DTOs.py` if needed).

### 3. Configuration
<!-- alwaysApply: true -->
- **Dedicated Config**: If the adapter requires specific configuration options, follow the pattern of creating a dedicated configuration module or classes, similar to existing adapters.
- **Clarity and Usability**: Configuration should be clear, well-documented, and easy for users to understand and provide.

### 4. Testing
<!-- alwaysApply: true -->
- **Comprehensive Tests**: New adapters MUST include both unit and integration tests.
    - **Unit Tests**: Place in `tests/unit/test_adapters/test_{adapter_name}/`. Mock external database interactions.
    - **Integration Tests**: Place in `tests/integration/test_adapters/test_{adapter_name}/`. Test against a real instance of the database, using `pytest-databases` or similar mechanisms if applicable.
- **Test Coverage**: Aim for high test coverage for all aspects of the adapter.

### 5. Documentation
<!-- alwaysApply: true -->
- **Docstrings**: Provide clear and comprehensive docstrings for all public classes, methods, and functions within the adapter.
- **Project Documentation**: Add a new section or page to the project documentation in `docs/` explaining how to use the new adapter, its configuration options, and any specific considerations.

### 6. Code Quality
<!-- alwaysApply: true -->
- Adhere to all general project coding standards, including those for style, typing, linting, and error handling as defined in other `.mdc` rule files (e.g., in `core/`, `python/`, `quality/`).

### 7. Execution Method Structure (MANDATORY)
<!-- alwaysApply: true -->
- **Mandatory Implementation**: All adapters MUST implement the standardized execution method structure
- **Reference Implementation**: SQLite adapter serves as the canonical reference for execution patterns
- **Cross-Reference**: See `.cursor/rules/adapters/01_execution_method_structure.mdc` for complete execution method requirements

### 8. Transaction Management (MANDATORY)
<!-- alwaysApply: true -->
- **No Implicit Transaction Control**: Adapters MUST NOT issue `commit()` or `rollback()` calls. Transaction management is always the responsibility of the end user unless an explicit exception is documented in the rules for a specific adapter.
- **Documentation**: This rule must be clearly documented in both code and user-facing documentation for each adapter.

### 9. Cross-Adapter Consistency (MANDATORY)
<!-- alwaysApply: true -->
- **Shared Logic**: Any change to one adapter that affects shared logic, processing patterns, or architectural principles MUST be reflected in all adapters, unless the change is driver-specific and this is explicitly documented.
- **Review Required**: When updating an adapter, review all other adapters for necessary parallel changes.

### 10. Unified Processing Pipeline (UNBREAKABLE RULE)
<!-- alwaysApply: true -->
- **Parse Once, Transform Once, Validate/Analyze Once**: All adapters and pipelines MUST follow the principle of a single-pass processing pipeline: parse once, transform once, validate and analyze once. This is an unbreakable rule unless an explicit exception is written in these rules.
- **Reference**: See `PIPELINE_OPTIMIZATION_SUMMARY.md` for rationale, implementation details, and performance benefits.
- **Cross-Reference**: See also `.cursor/rules/sql/00_sql_authoring.mdc` and `.cursor/rules/core/01_code_structure_style.mdc` for related pipeline and processing architecture rules.

### 11. Parameter Literalizer Caveats
<!-- alwaysApply: true -->
- **Known Tricky Area**: The parameter literalizer, which converts literals to bind parameters, is a known source of subtle bugs and test/debugging issues. Handle with extreme care. Any issues, workarounds, or deviations must be documented in the adapter and in the rules if they affect cross-adapter behavior.

### 12. Testing and Quality Requirements
<!-- alwaysApply: true -->
- **Testing Standards**: Follow comprehensive testing patterns for adapters
- **Mock Setup**: Use proper mock configuration for context managers and database interactions
- **Cross-Reference**: See `.cursor/rules/testing/01_adapter_testing_patterns.mdc` for specific testing requirements and patterns

### 13. Integration Requirements
<!-- alwaysApply: true -->
- **SQL Object Integration**: All adapters must properly integrate with SQL object parameter handling and execution mode detection
- **Pipeline Integration**: All adapters must integrate with the StatementPipeline and SQLProcessingContext architecture, ensuring a single-pass (parse/transform/validate/analyze once) pipeline. See [REF-011] in INTERNAL_REFERENCE.md for details.
- **Builder Support**: Adapters must seamlessly work with SQL builders and factory patterns

### 14. Database-Specific Considerations
<!-- alwaysApply: true -->
- **Placeholder Styles**: Implement appropriate placeholder style conversion for the target database
- **Connection Pooling**: Follow established patterns for connection pool management where applicable
- **Error Mapping**: Map database-specific errors to appropriate SQLSpec exception hierarchy
- **Feature Support**: Document database-specific feature support and limitations

### 15. Performance Considerations
<!-- alwaysApply: true -->
- **Efficient Execution**: Implement efficient execution paths for all three execution modes
- **Resource Management**: Proper cursor and connection lifecycle management
- **Batch Operations**: Optimize batch execution where supported by the database driver
- **Connection Reuse**: Leverage connection pooling and reuse patterns

## Cross-References
- See `.cursor/rules/adapters/01_execution_method_structure.mdc` for execution method requirements
- See `.cursor/rules/testing/01_adapter_testing_patterns.mdc` for testing patterns
- See `.cursor/rules/sql/01_sql_class_implementation.mdc` for SQL object integration
- See internal docs REF-005 through REF-007 for driver protocol architecture details

## Exceptions
- If a new database has fundamentally different paradigms that necessitate deviation from existing patterns, these deviations must be clearly justified and discussed with the project maintainers.
- Emergency hotfixes may temporarily deviate but must be documented and addressed in follow-up work.
