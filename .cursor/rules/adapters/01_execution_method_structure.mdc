---
description:
globs:
alwaysApply: false
---
# Adapter Execution Method Structure
<!-- alwaysApply: true -->

## Objective
To ensure all database adapters follow a unified, consistent execution method structure that enables proper debugging, testing, and maintenance across all supported databases, and correctly handles the SQL object's state.

## Context
- All adapters must implement the same execution method structure for consistency.
- The SQLite adapter serves as the reference implementation.
- Recent debugging revealed critical issues when adapters don't follow this structure, especially concerning SQL object state (`is_many`, `is_script`) and parameter handling.
- The execution flow must properly handle SQL object state and parameter management as defined in `sqlspec.statement.sql.SQL`.

## Rules

### 1. Mandatory Method Structure (UNBREAKABLE RULE)
<!-- alwaysApply: true -->
- **Required Methods**: All driver classes MUST define these methods in this exact order at the top of the class:
    1. `_execute_statement` — Main dispatch method.
    2. `_execute` — Single-statement execution.
    3. `_execute_many` — Batch/many execution.
    4. `_execute_script` — Script execution.

- **Method Signatures**: Must follow these exact signatures (type hints stringified):
    ```python
    def _execute_statement(
        self,
        statement: "SQL",
        connection: "Optional[ConnectionT]" = None,
        **kwargs: "Any"
    ) -> "Any":
        """Main dispatch method - determines execution mode and delegates."""

    def _execute(self, sql: "str", parameters: "SQLParameterType", connection: "ConnectionT", **kwargs: "Any") -> "Any":
        """Handle single-statement execution."""

    def _execute_many(self, sql: "str", parameters: "Sequence[SQLParameterType]", connection: "ConnectionT", **kwargs: "Any") -> "Any":
        """Handle batch/many execution."""

    def _execute_script(self, sql: "str", connection: "ConnectionT", **kwargs: "Any") -> "Any":
        """Handle script execution."""
    ```
- **Conciseness**: Each method should contain only the logic relevant to its execution mode. Methods must be as concise as possible, following strict in-lining and minimal variable rules.

### 2. Execution Flow Requirements (MANDATORY)
<!-- alwaysApply: true -->
- **SQL Object as Single Source of Truth**: The `SQL` object (passed as `statement`) must be the **authoritative source** for:
    - SQL string: Via `statement.to_sql(placeholder_style=...)`, ensuring the correct placeholder style for the execution context.
    - Parameters: Via `statement.parameters`.
    - Execution mode: Via `statement.is_many` and `statement.is_script` properties. **These properties MUST reflect the actual internal state of the `SQL` object and not any intermediate processing flags.**
- **No Separate Parameters/Flags**: The `_execute_statement` method must **NOT** accept separate `is_many`, `is_script`, or `parameters` arguments. It must rely solely on the passed `SQL` object.
- **Dispatch Logic**: The `_execute_statement` method must use the `statement.is_script` and `statement.is_many` properties to dispatch to the appropriate specialized execution method (`_execute_script`, `_execute_many`, or `_execute`).

    ```python
    # Example dispatch logic within _execute_statement
    def _execute_statement(self, statement: "SQL", connection: "Optional[ConnectionT]" = None, **kwargs: "Any") -> "Any":
        conn = connection or self._get_connection() # Adapter-specific connection retrieval

        if statement.is_script:
            # For scripts, parameters are baked into the SQL string via ParameterStyle.STATIC
            return self._execute_script(
                statement.to_sql(placeholder_style=ParameterStyle.STATIC), # MANDATORY
                connection=conn,
                **kwargs
            )
        elif statement.is_many:
            return self._execute_many(
                statement.to_sql(placeholder_style=self.placeholder_style), # Adapter's native placeholder
                statement.parameters, # These are Sequence[SQLParameterType]
                connection=conn,
                **kwargs
            )
        else: # Single execution
            return self._execute(
                statement.to_sql(placeholder_style=self.placeholder_style), # Adapter's native placeholder
                statement.parameters, # This is SQLParameterType
                connection=conn,
                **kwargs
            )
    ```

### 3. Parameter Handling Requirements (MANDATORY)
<!-- alwaysApply: true -->
- **Placeholder Style Conversion**: Use the adapter-specific `self.placeholder_style` for regular (`_execute`) and batch (`_execute_many`) execution.
- **Static Rendering for Scripts**: **Always** use `ParameterStyle.STATIC` when calling `statement.to_sql()` for script execution (`_execute_script`). This ensures all parameters are correctly substituted as literals into the SQL string, as scripts typically do not support bound parameters.
- **Parameter Trust**: Trust the `SQL` object's `statement.parameters` property. Adapters should not re-process or re-validate parameters.
- **Type Preservation**: Maintain parameter types as provided by the `SQL` object.

### 4. Result Wrapping Requirements (MANDATORY)
<!-- alwaysApply: true -->
- **Consistent Result Types**: Use methods like `_wrap_select_result` and `_wrap_execute_result` (as defined by adapter protocols) for consistent return types (e.g., `SelectResult`, `ExecuteResult`).
- **Row Detection**: Determine the result type based on cursor description (e.g., `cursor.description` is not `None` for SELECTs) or statement analysis provided by the `SQL` object if available.
- **Metadata Preservation**: Include execution metadata (row counts, timing, etc.) in result objects as applicable.

### 5. Connection Management (MANDATORY)
<!-- alwaysApply: true -->
- **Context Manager Usage**: All database operations that acquire a cursor MUST use proper context managers for cursors (e.g., `with self._get_cursor(connection) as cursor:`).
- **Resource Cleanup**: Ensure cursors and connections are properly closed or returned to connection pools. Context managers typically handle cursor cleanup.
- **Error Handling**: Wrap database-specific exceptions into `SQLSpec` exception hierarchy (e.g., `RepositoryError`, `IntegrityError`) using utilities like `sqlspec.exceptions.wrap_exceptions`.

### 6. Method Implementation Patterns (MANDATORY)
<!-- alwaysApply: true -->
- **Single Responsibility**: Each of the `_execute`, `_execute_many`, and `_execute_script` methods handles only its designated execution mode.
- **Minimal Variable Assignment**: Follow strict conciseness rules; inline expressions where possible.
- **Concise Naming**: Use `sql` for the SQL string argument and `parameters` for the parameters argument in the specialized execution methods.
- **Implementation Example (`_execute`)**:
    ```python
    def _execute(self, sql: "str", parameters: "SQLParameterType", connection: "ConnectionT", **kwargs: "Any") -> "Any":
        with self._get_cursor(connection) as cursor: # Ensures cursor cleanup
            # Placeholder for actual execution logic, e.g., using wrap_exceptions
            # with wrap_exceptions():
            #     cursor.execute(sql, parameters)
            cursor.execute(sql, parameters) # Example
            return self._wrap_select_result(cursor) if cursor.description else self._wrap_execute_result(cursor)
    ```

### 7. Transaction Management (MANDATORY)
<!-- alwaysApply: true -->
- **No Implicit Commits**: Adapters MUST NOT issue `commit()` or `rollback()` calls directly within these execution methods.
- **User Responsibility**: Transaction management is always the responsibility of the end-user or a higher-level unit-of-work pattern.
- **Documentation**: This rule must be clearly documented in adapter docstrings and any relevant user documentation.

### 8. Testing Requirements (MANDATORY)
<!-- alwaysApply: true -->
- **Execution Path Testing**: Test all three execution paths (single, many, script) independently for each adapter.
- **Parameter Flow Testing**: Verify parameters flow correctly from the `SQL` object to the database driver for all execution modes, respecting placeholder styles.
- **Mock Context Managers**: Use `MagicMock` for cursor mocks that require `__enter__`/`__exit__` support in unit tests.
- **Result Type Testing**: Verify correct result wrapping for SELECT vs. DML/DDL operations.
- **Cross-Reference**: See `.cursor/rules/testing/01_adapter_testing_patterns.mdc`.

### 9. Cross-Adapter Consistency (UNBREAKABLE RULE)
<!-- alwaysApply: true -->
- **Shared Pattern Updates**: Any change to these core execution patterns or `SQL` object interaction MUST be reflected in ALL adapters (sync and async).
- **Review Requirement**: When updating one adapter's execution logic, review all other adapters for necessary parallel changes to maintain consistency.
- **Reference Implementation**: The `sqlspec.adapters.sqlite.driver.SqliteDriver` serves as the canonical reference for this structure.

### 10. Integration Requirements (MANDATORY)
<!-- alwaysApply: true -->
- **StatementPipeline Integration**: Must work seamlessly with the `StatementPipeline` and `SQLProcessingContext` architecture by relying on the `SQL` object.
- **Single-Pass Processing**: Honor the "parse once, transform once, validate once" principle by using the fully processed `SQL` object.

## Cross-References
- See `.cursor/rules/sql/01_sql_class_implementation.mdc` for `SQL` object requirements, especially properties like `is_many`, `is_script`, and the behavior of `to_sql()`.
- See `.cursor/rules/testing/01_adapter_testing_patterns.mdc` for detailed testing patterns.
- See internal docs REF-005 for driver protocol architecture details and `ConnectionT` definitions.

## Exceptions
- Database-specific quirks (e.g., how scripts are executed if `executescript` is not available, or how batch operations are named) may require minor variations in the *body* of `_execute_script` or `_execute_many`, but the overall four-method structure, their signatures, the dispatch logic in `_execute_statement`, and the reliance on the `SQL` object for state and parameters are mandatory.
- Performance optimizations may be added within these methods but cannot change the core execution flow or contract with the `SQL` object.
